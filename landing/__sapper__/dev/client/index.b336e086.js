import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, a as assign, v as validate_slots, e as exclude_internal_props, b as svg_element, c as claim_element, f as children, g as detach_dev, h as attr_dev, j as add_location, k as set_svg_attributes, l as insert_dev, m as append_dev, n as get_spread_update, o as noop, w as writable, p as validate_each_argument, q as validate_store, r as component_subscribe, t as element, u as text, x as space, y as claim_text, z as claim_space, A as listen_dev, B as set_data_dev, C as toggle_class, D as create_component, E as claim_component, F as mount_component, G as transition_in, H as transition_out, I as destroy_component, J as destroy_each, K as onMount, L as action_destroyer } from './client.a0ed014d.js';

/* src/icons/Arrow.svg generated by Svelte v3.21.0 */

const file = "src/icons/Arrow.svg";

function create_fragment(ctx) {
	let svg;
	let path;

	let svg_levels = [
		{ width: "16" },
		{ height: "16" },
		{ viewBox: "0 0 16 16" },
		{ fill: "none" },
		{ xmlns: "http://www.w3.org/2000/svg" },
		/*$$props*/ ctx[0]
	];

	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = assign(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					width: true,
					height: true,
					viewBox: true,
					fill: true,
					xmlns: true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { d: true, fill: true }, 1);
			children(path).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M0 4H16L8 16L0 4Z");
			attr_dev(path, "fill", "#731DD8");
			add_location(path, file, 1, 0, 109);
			set_svg_attributes(svg, svg_data);
			add_location(svg, file, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: function update(ctx, [dirty]) {
			set_svg_attributes(svg, get_spread_update(svg_levels, [
				{ width: "16" },
				{ height: "16" },
				{ viewBox: "0 0 16 16" },
				{ fill: "none" },
				{ xmlns: "http://www.w3.org/2000/svg" },
				dirty & /*$$props*/ 1 && /*$$props*/ ctx[0]
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Arrow", $$slots, []);

	$$self.$set = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
	};

	$$self.$inject_state = $$new_props => {
		$$invalidate(0, $$props = assign(assign({}, $$props), $$new_props));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [$$props];
}

class Arrow extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Arrow",
			options,
			id: create_fragment.name
		});
	}
}

var currentLanguage = "укр";
var languages = [
	{
		key: "ua",
		name: "українська"
	},
	{
		key: "ru",
		name: "російська"
	}
];
var menu = {
	download: "Завантажити",
	advantages: "Переваги",
	features: "Особливості",
	contact: "Зв’язатись"
};
var download = {
	title: "Medlibra",
	titleDescription: "мобільний застосунок №1 для підготовки до КРОК",
	downloadFree: "Завантажити безкоштовно"
};
var advantages = {
	overview: [
		{
			title: "5",
			content: "Типів КРОК\n(1, 2, 3, М, Б)"
		},
		{
			title: "20",
			content: "Окремих\nспеціалізацій"
		},
		{
			title: "3 000",
			content: "Буклетів та\nбаз"
		},
		{
			title: "160 000",
			content: "Унікальних\nпитань"
		}
	],
	infographics: [
		{
			title: "Найбільша бібліотека тестів",
			content: "Найповніша база тестів. Починайте навчання одразу, без потреби шукати необхідне"
		},
		{
			title: "Доступ офлайн",
			content: "Швидке і зручне завантаження тестів до офлайну. Усі потрібні тести доступні будь-коли"
		},
		{
			title: "Збереження питань",
			content: "Жодних скріншотів. Зберігайте складні або незрозумілі питання прямо у застосунку"
		},
		{
			title: "Зручний інтерфейс",
			content: "Нічого зайвого. Ви бачите лише тести з власної спеціалізації. Режими день/ніч допоможуть очам не перевтомлюватись"
		},
		{
			title: "Контроль прогресу",
			content: "Відслідковуйте рівень власних знань. Вибудовуйте таку стратегію навчання, як вам зручно"
		}
	]
};
var features = {
	title: "Особливості роботи. Як працює застосунок для КРОК Medlibra?",
	content: [
		"Перш за все, повноцінно використовуючи застосунок, ви зможете максимально наблизити себе до умов проходження іспиту КРОК.\n\nПо-друге, застосунок допоможе вам максимально якісно підготуватись до тестових питань завдяки різним режимам тестування (іспит та тренування), що дає можливість перевірити себе в різних умовах та закріпити вивчений матеріал.\n\nПо-третє, продумані та зручні особливості додатку допоможуть у наступних ситуаціях:\n– Щоб відслідковувати свій успіх та розуміти, наскільки добре йде підготовка, створено різні типи статистик та історій проходження тестів.\n– Незрозуміле конкретне питання – не проблема, його можна зберегти та навчатись далі, щоб повернутись до нього згодом.",
		"– Знайти відповідь на складне питання не вдалося? Є можливість перевірити коментарі: інші користувачі можуть залишити посилання на літературу або поділись цим питанням з іншими одразу із застосунку.\n\n– Якщо є перебої з інтернетом – не проблема! Додаток Medlibra працює без підключення до інтернету і дозволяє без обмежень готуватись у зручний для себе час.\n\n– Інтуїтивно зрозуміла навігація дає змогу не витрачати зусиль на безглузде вивчення інструкцій.\nЗастосунок Medlibra створено для допомоги студентам у підготовці до тестування КРОК. Він працює з Android та iOS і дає змогу, незалежно від смартфону, однаково зручно навчитись проходити тестування, адже тут є буклети і бази з більш ніж 160 000 питань."
	],
	testBaseTitle: "База тестів Крок у Medlibra",
	testBaseContent: [
		"Яким чином допомогти студентам-медикам у навчанні? Про це подумала команда розробників застосунку Medlibra. Ними було створено зручну програму для підготовки до тестів КРОК 1, КРОК 2, КРОК 3, КРОК М, КРОК Б, що складається з численних буклетів та баз по всіх медичних спеціальностях.\n\nВикористовуючи для підготовки до тестування цей застосунок, ви з легкістю опануєте будь-які тести КРОК. Він поєднує у собі продумані та зручні функціональності разом з інтуїтивно зрозумілим використанням.\nНагадаємо, що ви маєте можливість зберігати питання у програмі для їх подальшого вивчення, а також ділитись незрозумілими питаннями тесту з друзями, слідкувати за прогресом підготовки, отримувати нагороди за досягнення, тощо. Але одними з найголовніших переваг Medlibra є відсутність необхідності постійного підключення до інтернету та найбільш повна база буклетів та баз КРОК.\n\nНаші майбутні лікарі мають право на зручне та комфортне навчання, незалежне від сторонніх факторів, та протягом усього перебування у стінах ЗВО.\n\nMedlibra покликана допомогти зручно підготуватись до іспиту з медичних спеціальностей за будь-якої ситуації завдяки зручному інтерфейсу, унікальним особливостям і найповнішій бібліотеці буклетів та баз КРОК.\nУвага! Розробники не несуть відповідальності за сумнівне використання застосунку, адже його розроблено винятково для допомоги у навчанні та підготовці до іспитів.",
		"В застосунку є наступні предмети та бази:\n\n1) КРОК 1\n– Стоматологія\n– Лікувальна справа\n– Фармація\n\n2) КРОК 2 містить у собі інформацію з предметів:\n– Стоматологія\n– Лікувальна справа\n– Медична психологія\n– Лабораторна діагностика\n– Фармація\n– Клінічна фармація\n– Косметологія\n\n3) КРОК 3 складається з предметів:\n– Стоматологія\n– Лабораторна діагностика\n– Лікувальна справа\n\n4) Готуйтесь до КРОК М, Б зі спеціальностей:\n– Акушерська справа\n– Лікувальна справа\n– Медична профілактика\n– Сестринська справа\n– Лабораторна діагностика"
	]
};
var contactUs = "Написати розробникам";
var copyright = "© Medlibra 2020. Усі права захищено";
var ua = {
	currentLanguage: currentLanguage,
	languages: languages,
	menu: menu,
	download: download,
	advantages: advantages,
	features: features,
	contactUs: contactUs,
	copyright: copyright
};

const global = globalThis || window || global;

const KEY = 'currentLanguage';
const cache = { ua };

async function setLocale(locale) {
  const nextLocale =
    cache[locale] || (await (await fetch(`/locales/${locale}.json`)).json());
  localization.set(nextLocale);
  cache[locale] = nextLocale;
  global.localStorage && global.localStorage.setItem(KEY, locale);
}

if (!!global.localStorage) {
  const initialLanguage = global.localStorage.getItem(KEY);

  if (initialLanguage !== 'ua' && initialLanguage !== null) {
    setLocale(initialLanguage);
  }
}

const localization = writable(ua);

/* src/components/Header.svelte generated by Svelte v3.21.0 */
const file$1 = "src/components/Header.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	return child_ctx;
}

// (201:10) {#each $localization.languages as language}
function create_each_block_1(ctx) {
	let div;
	let t0_value = /*language*/ ctx[7].name + "";
	let t0;
	let t1;
	let dispose;

	function mousedown_handler(...args) {
		return /*mousedown_handler*/ ctx[3](/*language*/ ctx[7], ...args);
	}

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-pp14cf");
			add_location(div, file$1, 201, 12, 3598);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			if (remount) dispose();
			dispose = listen_dev(div, "mousedown", mousedown_handler, false, false, false);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$localization*/ 4 && t0_value !== (t0_value = /*language*/ ctx[7].name + "")) set_data_dev(t0, t0_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(201:10) {#each $localization.languages as language}",
		ctx
	});

	return block;
}

// (211:6) {#each menuItems as item}
function create_each_block(ctx) {
	let a;
	let t0_value = /*item*/ ctx[4].title + "";
	let t0;
	let t1;
	let a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			t0 = claim_text(a_nodes, t0_value);
			t1 = claim_space(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(a, "class", "text-inactive svelte-pp14cf");
			attr_dev(a, "href", a_href_value = /*item*/ ctx[4].link);
			toggle_class(a, "active", /*item*/ ctx[4].link === `#${/*currentObservedItem*/ ctx[0]}`);
			add_location(a, file$1, 211, 8, 3827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t0);
			append_dev(a, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*menuItems*/ 2 && t0_value !== (t0_value = /*item*/ ctx[4].title + "")) set_data_dev(t0, t0_value);

			if (dirty & /*menuItems*/ 2 && a_href_value !== (a_href_value = /*item*/ ctx[4].link)) {
				attr_dev(a, "href", a_href_value);
			}

			if (dirty & /*menuItems, currentObservedItem*/ 3) {
				toggle_class(a, "active", /*item*/ ctx[4].link === `#${/*currentObservedItem*/ ctx[0]}`);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(211:6) {#each menuItems as item}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let header;
	let div5;
	let div3;
	let a;
	let img;
	let img_src_value;
	let t0;
	let div2;
	let div0;
	let t1;
	let span;
	let t2_value = /*$localization*/ ctx[2].currentLanguage + "";
	let t2;
	let t3;
	let t4;
	let div1;
	let t5;
	let div4;
	let current;
	const arrow = new Arrow({ $$inline: true });
	let each_value_1 = /*$localization*/ ctx[2].languages;
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	let each_value = /*menuItems*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			header = element("header");
			div5 = element("div");
			div3 = element("div");
			a = element("a");
			img = element("img");
			t0 = space();
			div2 = element("div");
			div0 = element("div");
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();
			create_component(arrow.$$.fragment);
			t4 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t5 = space();
			div4 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			div5 = claim_element(header_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			a = claim_element(div3_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			img = claim_element(a_nodes, "IMG", { class: true, src: true, alt: true });
			a_nodes.forEach(detach_dev);
			t0 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true, href: true, tabindex: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true, tabindex: true });
			children(div0).forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			span = claim_element(div2_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			claim_component(arrow.$$.fragment, div2_nodes);
			t4 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true, tabindex: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t5 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div4_nodes);
			}

			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "logo svelte-pp14cf");
			if (img.src !== (img_src_value = "/images/Logo.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "medlibra");
			add_location(img, file$1, 192, 8, 3219);
			attr_dev(a, "class", "home svelte-pp14cf");
			attr_dev(a, "href", "/");
			add_location(a, file$1, 191, 6, 3185);
			attr_dev(div0, "class", "language-overlay svelte-pp14cf");
			attr_dev(div0, "tabindex", "0");
			add_location(div0, file$1, 196, 8, 3364);
			attr_dev(span, "class", "svelte-pp14cf");
			add_location(span, file$1, 197, 8, 3418);
			attr_dev(div1, "class", "language-select svelte-pp14cf");
			attr_dev(div1, "tabindex", "0");
			add_location(div1, file$1, 199, 8, 3489);
			attr_dev(div2, "class", "language text-secondary svelte-pp14cf");
			attr_dev(div2, "href", "/");
			attr_dev(div2, "tabindex", "0");
			add_location(div2, file$1, 195, 6, 3296);
			attr_dev(div3, "class", "segment main svelte-pp14cf");
			add_location(div3, file$1, 190, 4, 3152);
			attr_dev(div4, "class", "segment menu svelte-pp14cf");
			add_location(div4, file$1, 209, 4, 3760);
			attr_dev(div5, "class", "container svelte-pp14cf");
			add_location(div5, file$1, 189, 2, 3124);
			attr_dev(header, "class", "svelte-pp14cf");
			add_location(header, file$1, 188, 0, 3113);
		},
		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);
			append_dev(header, div5);
			append_dev(div5, div3);
			append_dev(div3, a);
			append_dev(a, img);
			append_dev(div3, t0);
			append_dev(div3, div2);
			append_dev(div2, div0);
			append_dev(div2, t1);
			append_dev(div2, span);
			append_dev(span, t2);
			append_dev(div2, t3);
			mount_component(arrow, div2, null);
			append_dev(div2, t4);
			append_dev(div2, div1);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div1, null);
			}

			append_dev(div5, t5);
			append_dev(div5, div4);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div4, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*$localization*/ 4) && t2_value !== (t2_value = /*$localization*/ ctx[2].currentLanguage + "")) set_data_dev(t2, t2_value);

			if (dirty & /*setLocale, $localization*/ 4) {
				each_value_1 = /*$localization*/ ctx[2].languages;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div1, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*menuItems, currentObservedItem*/ 3) {
				each_value = /*menuItems*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div4, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(arrow.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(arrow.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
			destroy_component(arrow);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $localization;
	validate_store(localization, "localization");
	component_subscribe($$self, localization, $$value => $$invalidate(2, $localization = $$value));
	let { currentObservedItem } = $$props;
	const writable_props = ["currentObservedItem"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Header", $$slots, []);
	const mousedown_handler = language => setLocale(language.key);

	$$self.$set = $$props => {
		if ("currentObservedItem" in $$props) $$invalidate(0, currentObservedItem = $$props.currentObservedItem);
	};

	$$self.$capture_state = () => ({
		Arrow,
		setLocale,
		localization,
		currentObservedItem,
		menuItems,
		$localization
	});

	$$self.$inject_state = $$props => {
		if ("currentObservedItem" in $$props) $$invalidate(0, currentObservedItem = $$props.currentObservedItem);
		if ("menuItems" in $$props) $$invalidate(1, menuItems = $$props.menuItems);
	};

	let menuItems;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$localization*/ 4) {
			 $$invalidate(1, menuItems = [
				{
					link: "#download",
					title: $localization.menu.download
				},
				{
					link: "#advantages",
					title: $localization.menu.advantages
				},
				{
					link: "#features",
					title: $localization.menu.features
				},
				{
					link: "#contact",
					title: $localization.menu.contact
				}
			]);
		}
	};

	return [currentObservedItem, menuItems, $localization, mousedown_handler];
}

class Header extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { currentObservedItem: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Header",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*currentObservedItem*/ ctx[0] === undefined && !("currentObservedItem" in props)) {
			console.warn("<Header> was created without expected prop 'currentObservedItem'");
		}
	}

	get currentObservedItem() {
		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentObservedItem(value) {
		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Background.svelte generated by Svelte v3.21.0 */
const file$2 = "src/components/Background.svelte";

function create_fragment$2(ctx) {
	let div;
	let img0;
	let img0_src_value;
	let t;
	let img1;
	let img1_src_value;

	const block = {
		c: function create() {
			div = element("div");
			img0 = element("img");
			t = space();
			img1 = element("img");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			img0 = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
			t = claim_space(div_nodes);
			img1 = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(img0, "class", "light svelte-1ga20bz");
			if (img0.src !== (img0_src_value = "/images/light.png")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "light");
			add_location(img0, file$2, 92, 2, 1263);
			attr_dev(img1, "class", "dark svelte-1ga20bz");
			if (img1.src !== (img1_src_value = "/images/dark.png")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "dark");
			add_location(img1, file$2, 93, 2, 1323);
			attr_dev(div, "class", "background svelte-1ga20bz");
			toggle_class(div, "mounted", /*mounted*/ ctx[0]);
			add_location(div, file$2, 91, 0, 1222);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, img0);
			append_dev(div, t);
			append_dev(div, img1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*mounted*/ 1) {
				toggle_class(div, "mounted", /*mounted*/ ctx[0]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let mounted = false;

	onMount(() => {
		setTimeout(
			() => {
				$$invalidate(0, mounted = true);
			},
			200
		);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Background> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Background", $$slots, []);
	$$self.$capture_state = () => ({ onMount, mounted });

	$$self.$inject_state = $$props => {
		if ("mounted" in $$props) $$invalidate(0, mounted = $$props.mounted);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mounted];
}

class Background extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Background",
			options,
			id: create_fragment$2.name
		});
	}
}

/* src/components/Download.svelte generated by Svelte v3.21.0 */
const file$3 = "src/components/Download.svelte";

function create_fragment$3(ctx) {
	let div7;
	let h1;
	let t0_value = /*$localization*/ ctx[0].download.title + "";
	let t0;
	let t1;
	let br0;
	let t2;
	let br1;
	let t3;
	let t4_value = /*$localization*/ ctx[0].download.titleDescription + "";
	let t4;
	let t5;
	let h3;
	let t6_value = /*$localization*/ ctx[0].download.downloadFree + "";
	let t6;
	let t7;
	let div6;
	let a0;
	let div0;
	let svg0;
	let defs0;
	let linearGradient0;
	let stop0;
	let stop1;
	let rect0;
	let t8;
	let div2;
	let img0;
	let img0_src_value;
	let t9;
	let div1;
	let span0;
	let t10;
	let t11;
	let a1;
	let div3;
	let svg1;
	let defs1;
	let linearGradient1;
	let stop2;
	let stop3;
	let stop4;
	let stop5;
	let rect1;
	let t12;
	let div5;
	let img1;
	let img1_src_value;
	let t13;
	let div4;
	let span1;
	let t14;

	const block = {
		c: function create() {
			div7 = element("div");
			h1 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			br0 = element("br");
			t2 = space();
			br1 = element("br");
			t3 = space();
			t4 = text(t4_value);
			t5 = space();
			h3 = element("h3");
			t6 = text(t6_value);
			t7 = space();
			div6 = element("div");
			a0 = element("a");
			div0 = element("div");
			svg0 = svg_element("svg");
			defs0 = svg_element("defs");
			linearGradient0 = svg_element("linearGradient");
			stop0 = svg_element("stop");
			stop1 = svg_element("stop");
			rect0 = svg_element("rect");
			t8 = space();
			div2 = element("div");
			img0 = element("img");
			t9 = space();
			div1 = element("div");
			span0 = element("span");
			t10 = text("AppStore");
			t11 = space();
			a1 = element("a");
			div3 = element("div");
			svg1 = svg_element("svg");
			defs1 = svg_element("defs");
			linearGradient1 = svg_element("linearGradient");
			stop2 = svg_element("stop");
			stop3 = svg_element("stop");
			stop4 = svg_element("stop");
			stop5 = svg_element("stop");
			rect1 = svg_element("rect");
			t12 = space();
			div5 = element("div");
			img1 = element("img");
			t13 = space();
			div4 = element("div");
			span1 = element("span");
			t14 = text("PlayMarket");
			this.h();
		},
		l: function claim(nodes) {
			div7 = claim_element(nodes, "DIV", { class: true, id: true });
			var div7_nodes = children(div7);
			h1 = claim_element(div7_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, t0_value);
			t1 = claim_space(h1_nodes);
			br0 = claim_element(h1_nodes, "BR", {});
			t2 = claim_space(h1_nodes);
			br1 = claim_element(h1_nodes, "BR", {});
			t3 = claim_space(h1_nodes);
			t4 = claim_text(h1_nodes, t4_value);
			h1_nodes.forEach(detach_dev);
			t5 = claim_space(div7_nodes);
			h3 = claim_element(div7_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t6 = claim_text(h3_nodes, t6_value);
			h3_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			div6 = claim_element(div7_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			a0 = claim_element(div6_nodes, "A", { href: true, class: true });
			var a0_nodes = children(a0);
			div0 = claim_element(a0_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			svg0 = claim_element(div0_nodes, "svg", { width: true, height: true, class: true }, 1);
			var svg0_nodes = children(svg0);
			defs0 = claim_element(svg0_nodes, "defs", {}, 1);
			var defs0_nodes = children(defs0);

			linearGradient0 = claim_element(
				defs0_nodes,
				"linearGradient",
				{
					id: true,
					x1: true,
					y1: true,
					x2: true,
					y2: true
				},
				1
			);

			var linearGradient0_nodes = children(linearGradient0);
			stop0 = claim_element(linearGradient0_nodes, "stop", { offset: true, "stop-color": true }, 1);
			children(stop0).forEach(detach_dev);
			stop1 = claim_element(linearGradient0_nodes, "stop", { offset: true, "stop-color": true }, 1);
			children(stop1).forEach(detach_dev);
			linearGradient0_nodes.forEach(detach_dev);
			defs0_nodes.forEach(detach_dev);

			rect0 = claim_element(
				svg0_nodes,
				"rect",
				{
					x: true,
					y: true,
					rx: true,
					ry: true,
					width: true,
					fill: true,
					height: true,
					stroke: true,
					"stroke-width": true
				},
				1
			);

			children(rect0).forEach(detach_dev);
			svg0_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t8 = claim_space(a0_nodes);
			div2 = claim_element(a0_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			img0 = claim_element(div2_nodes, "IMG", { src: true, alt: true, class: true });
			t9 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span0 = claim_element(div1_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t10 = claim_text(span0_nodes, "AppStore");
			span0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			a0_nodes.forEach(detach_dev);
			t11 = claim_space(div6_nodes);
			a1 = claim_element(div6_nodes, "A", { href: true, class: true });
			var a1_nodes = children(a1);
			div3 = claim_element(a1_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			svg1 = claim_element(div3_nodes, "svg", { width: true, height: true, class: true }, 1);
			var svg1_nodes = children(svg1);
			defs1 = claim_element(svg1_nodes, "defs", {}, 1);
			var defs1_nodes = children(defs1);

			linearGradient1 = claim_element(
				defs1_nodes,
				"linearGradient",
				{
					id: true,
					x1: true,
					y1: true,
					x2: true,
					y2: true
				},
				1
			);

			var linearGradient1_nodes = children(linearGradient1);
			stop2 = claim_element(linearGradient1_nodes, "stop", { offset: true, "stop-color": true }, 1);
			children(stop2).forEach(detach_dev);
			stop3 = claim_element(linearGradient1_nodes, "stop", { offset: true, "stop-color": true }, 1);
			children(stop3).forEach(detach_dev);
			stop4 = claim_element(linearGradient1_nodes, "stop", { offset: true, "stop-color": true }, 1);
			children(stop4).forEach(detach_dev);
			stop5 = claim_element(linearGradient1_nodes, "stop", { offset: true, "stop-color": true }, 1);
			children(stop5).forEach(detach_dev);
			linearGradient1_nodes.forEach(detach_dev);
			defs1_nodes.forEach(detach_dev);

			rect1 = claim_element(
				svg1_nodes,
				"rect",
				{
					x: true,
					y: true,
					rx: true,
					ry: true,
					width: true,
					fill: true,
					height: true,
					stroke: true,
					"stroke-width": true
				},
				1
			);

			children(rect1).forEach(detach_dev);
			svg1_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t12 = claim_space(a1_nodes);
			div5 = claim_element(a1_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			img1 = claim_element(div5_nodes, "IMG", { src: true, alt: true, class: true });
			t13 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			span1 = claim_element(div4_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t14 = claim_text(span1_nodes, "PlayMarket");
			span1_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			a1_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			div7_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(br0, file$3, 140, 4, 2208);
			add_location(br1, file$3, 141, 4, 2219);
			attr_dev(h1, "class", "text-primary svelte-8a2ssr");
			add_location(h1, file$3, 138, 2, 2143);
			attr_dev(h3, "class", "text-secondary svelte-8a2ssr");
			add_location(h3, file$3, 145, 2, 2283);
			attr_dev(stop0, "offset", "0%");
			attr_dev(stop0, "stop-color", "#1AC6FB");
			add_location(stop0, file$3, 158, 14, 2659);
			attr_dev(stop1, "offset", "100%");
			attr_dev(stop1, "stop-color", "#1C72F0");
			add_location(stop1, file$3, 159, 14, 2715);
			attr_dev(linearGradient0, "id", "gradient-appstore");
			attr_dev(linearGradient0, "x1", "0%");
			attr_dev(linearGradient0, "y1", "0%");
			attr_dev(linearGradient0, "x2", "100%");
			attr_dev(linearGradient0, "y2", "0%");
			add_location(linearGradient0, file$3, 152, 12, 2501);
			add_location(defs0, file$3, 151, 10, 2482);
			attr_dev(rect0, "x", "1");
			attr_dev(rect0, "y", "1");
			attr_dev(rect0, "rx", "16");
			attr_dev(rect0, "ry", "16");
			attr_dev(rect0, "width", "calc(100% - 2px)");
			attr_dev(rect0, "fill", "rgba(254, 251, 246, 0.05)");
			attr_dev(rect0, "height", "calc(100% - 2px)");
			attr_dev(rect0, "stroke", "url(#gradient-appstore)");
			attr_dev(rect0, "stroke-width", "2");
			add_location(rect0, file$3, 162, 10, 2817);
			attr_dev(svg0, "width", "100%");
			attr_dev(svg0, "height", "100%");
			attr_dev(svg0, "class", "svelte-8a2ssr");
			add_location(svg0, file$3, 150, 8, 2439);
			attr_dev(div0, "class", "border svelte-8a2ssr");
			add_location(div0, file$3, 149, 6, 2410);
			if (img0.src !== (img0_src_value = "/images/appstore.svg")) attr_dev(img0, "src", img0_src_value);
			attr_dev(img0, "alt", "app store");
			attr_dev(img0, "class", "svelte-8a2ssr");
			add_location(img0, file$3, 176, 8, 3161);
			attr_dev(span0, "class", "text-accent text-primary svelte-8a2ssr");
			add_location(span0, file$3, 178, 10, 3257);
			attr_dev(div1, "class", "text-content svelte-8a2ssr");
			add_location(div1, file$3, 177, 8, 3220);
			attr_dev(div2, "class", "content svelte-8a2ssr");
			add_location(div2, file$3, 175, 6, 3131);
			attr_dev(a0, "href", "/");
			attr_dev(a0, "class", "svelte-8a2ssr");
			add_location(a0, file$3, 148, 4, 2391);
			attr_dev(stop2, "offset", "0%");
			attr_dev(stop2, "stop-color", "#00E0FF");
			add_location(stop2, file$3, 193, 14, 3624);
			attr_dev(stop3, "offset", "33%");
			attr_dev(stop3, "stop-color", "#00F085");
			add_location(stop3, file$3, 194, 14, 3680);
			attr_dev(stop4, "offset", "66%");
			attr_dev(stop4, "stop-color", "#FFE300");
			add_location(stop4, file$3, 195, 14, 3737);
			attr_dev(stop5, "offset", "100%");
			attr_dev(stop5, "stop-color", "#FF4E54");
			add_location(stop5, file$3, 196, 14, 3794);
			attr_dev(linearGradient1, "id", "gradient-playmarket");
			attr_dev(linearGradient1, "x1", "0%");
			attr_dev(linearGradient1, "y1", "0%");
			attr_dev(linearGradient1, "x2", "100%");
			attr_dev(linearGradient1, "y2", "0%");
			add_location(linearGradient1, file$3, 187, 12, 3464);
			add_location(defs1, file$3, 186, 10, 3445);
			attr_dev(rect1, "x", "1");
			attr_dev(rect1, "y", "1");
			attr_dev(rect1, "rx", "16");
			attr_dev(rect1, "ry", "16");
			attr_dev(rect1, "width", "calc(100% - 2px)");
			attr_dev(rect1, "fill", "rgba(254, 251, 246, 0.05)");
			attr_dev(rect1, "height", "calc(100% - 2px)");
			attr_dev(rect1, "stroke", "url(#gradient-playmarket)");
			attr_dev(rect1, "stroke-width", "2");
			add_location(rect1, file$3, 199, 10, 3896);
			attr_dev(svg1, "width", "100%");
			attr_dev(svg1, "height", "100%");
			attr_dev(svg1, "class", "svelte-8a2ssr");
			add_location(svg1, file$3, 185, 8, 3402);
			attr_dev(div3, "class", "border svelte-8a2ssr");
			add_location(div3, file$3, 184, 6, 3373);
			if (img1.src !== (img1_src_value = "/images/playstore.svg")) attr_dev(img1, "src", img1_src_value);
			attr_dev(img1, "alt", "play market");
			attr_dev(img1, "class", "svelte-8a2ssr");
			add_location(img1, file$3, 213, 8, 4242);
			attr_dev(span1, "class", "text-accent text-primary svelte-8a2ssr");
			add_location(span1, file$3, 215, 10, 4341);
			attr_dev(div4, "class", "text-content svelte-8a2ssr");
			add_location(div4, file$3, 214, 8, 4304);
			attr_dev(div5, "class", "content svelte-8a2ssr");
			add_location(div5, file$3, 212, 6, 4212);
			attr_dev(a1, "href", "/");
			attr_dev(a1, "class", "svelte-8a2ssr");
			add_location(a1, file$3, 183, 4, 3354);
			attr_dev(div6, "class", "download-buttons svelte-8a2ssr");
			add_location(div6, file$3, 147, 2, 2356);
			attr_dev(div7, "class", "path container svelte-8a2ssr");
			attr_dev(div7, "id", "download");
			add_location(div7, file$3, 137, 0, 2098);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div7, anchor);
			append_dev(div7, h1);
			append_dev(h1, t0);
			append_dev(h1, t1);
			append_dev(h1, br0);
			append_dev(h1, t2);
			append_dev(h1, br1);
			append_dev(h1, t3);
			append_dev(h1, t4);
			append_dev(div7, t5);
			append_dev(div7, h3);
			append_dev(h3, t6);
			append_dev(div7, t7);
			append_dev(div7, div6);
			append_dev(div6, a0);
			append_dev(a0, div0);
			append_dev(div0, svg0);
			append_dev(svg0, defs0);
			append_dev(defs0, linearGradient0);
			append_dev(linearGradient0, stop0);
			append_dev(linearGradient0, stop1);
			append_dev(svg0, rect0);
			append_dev(a0, t8);
			append_dev(a0, div2);
			append_dev(div2, img0);
			append_dev(div2, t9);
			append_dev(div2, div1);
			append_dev(div1, span0);
			append_dev(span0, t10);
			append_dev(div6, t11);
			append_dev(div6, a1);
			append_dev(a1, div3);
			append_dev(div3, svg1);
			append_dev(svg1, defs1);
			append_dev(defs1, linearGradient1);
			append_dev(linearGradient1, stop2);
			append_dev(linearGradient1, stop3);
			append_dev(linearGradient1, stop4);
			append_dev(linearGradient1, stop5);
			append_dev(svg1, rect1);
			append_dev(a1, t12);
			append_dev(a1, div5);
			append_dev(div5, img1);
			append_dev(div5, t13);
			append_dev(div5, div4);
			append_dev(div4, span1);
			append_dev(span1, t14);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$localization*/ 1 && t0_value !== (t0_value = /*$localization*/ ctx[0].download.title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*$localization*/ 1 && t4_value !== (t4_value = /*$localization*/ ctx[0].download.titleDescription + "")) set_data_dev(t4, t4_value);
			if (dirty & /*$localization*/ 1 && t6_value !== (t6_value = /*$localization*/ ctx[0].download.downloadFree + "")) set_data_dev(t6, t6_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $localization;
	validate_store(localization, "localization");
	component_subscribe($$self, localization, $$value => $$invalidate(0, $localization = $$value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Download> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Download", $$slots, []);
	$$self.$capture_state = () => ({ localization, $localization });
	return [$localization];
}

class Download extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Download",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/components/Advantages.svelte generated by Svelte v3.21.0 */
const file$4 = "src/components/Advantages.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	child_ctx[3] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

// (265:6) {#each $localization.advantages.overview as overview}
function create_each_block_1$1(ctx) {
	let div;
	let h2;
	let t0_value = /*overview*/ ctx[4].title + "";
	let t0;
	let t1;
	let h3;
	let t2_value = /*overview*/ ctx[4].content + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			h3 = element("h3");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h2 = claim_element(div_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, t0_value);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			h3 = claim_element(div_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t2 = claim_text(h3_nodes, t2_value);
			h3_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "text-primary svelte-15otg7s");
			add_location(h2, file$4, 266, 10, 4667);
			attr_dev(h3, "class", "text-secondary svelte-15otg7s");
			add_location(h3, file$4, 267, 10, 4724);
			attr_dev(div, "class", "item svelte-15otg7s");
			add_location(div, file$4, 265, 8, 4638);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h2);
			append_dev(h2, t0);
			append_dev(div, t1);
			append_dev(div, h3);
			append_dev(h3, t2);
			append_dev(div, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$localization*/ 1 && t0_value !== (t0_value = /*overview*/ ctx[4].title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*$localization*/ 1 && t2_value !== (t2_value = /*overview*/ ctx[4].content + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(265:6) {#each $localization.advantages.overview as overview}",
		ctx
	});

	return block;
}

// (275:4) {#each $localization.advantages.infographics as infographics, index}
function create_each_block$1(ctx) {
	let div1;
	let img;
	let img_src_value;
	let appear_action;
	let t0;
	let div0;
	let h2;
	let t1_value = /*infographics*/ ctx[1].title + "";
	let t1;
	let t2;
	let h3;
	let t3_value = /*infographics*/ ctx[1].content + "";
	let t3;
	let t4;
	let dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			img = element("img");
			t0 = space();
			div0 = element("div");
			h2 = element("h2");
			t1 = text(t1_value);
			t2 = space();
			h3 = element("h3");
			t3 = text(t3_value);
			t4 = space();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			img = claim_element(div1_nodes, "IMG", { src: true, alt: true, class: true });
			t0 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			h2 = claim_element(div0_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t1 = claim_text(h2_nodes, t1_value);
			h2_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);
			h3 = claim_element(div0_nodes, "H3", { class: true });
			var h3_nodes = children(h3);
			t3 = claim_text(h3_nodes, t3_value);
			h3_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "/images/illustration" + (/*index*/ ctx[3] + 1) + ".svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "img");
			attr_dev(img, "class", "svelte-15otg7s");
			add_location(img, file$4, 276, 8, 4965);
			attr_dev(h2, "class", "text-primary svelte-15otg7s");
			add_location(h2, file$4, 279, 10, 5061);
			attr_dev(h3, "class", "text-secondary svelte-15otg7s");
			add_location(h3, file$4, 280, 10, 5122);
			attr_dev(div0, "class", "svelte-15otg7s");
			add_location(div0, file$4, 278, 8, 5045);
			attr_dev(div1, "class", "infographics svelte-15otg7s");
			add_location(div1, file$4, 275, 6, 4930);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, div1, anchor);
			append_dev(div1, img);
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, h2);
			append_dev(h2, t1);
			append_dev(div0, t2);
			append_dev(div0, h3);
			append_dev(h3, t3);
			append_dev(div1, t4);
			if (remount) dispose();
			dispose = action_destroyer(appear_action = appear.call(null, img));
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$localization*/ 1 && t1_value !== (t1_value = /*infographics*/ ctx[1].title + "")) set_data_dev(t1, t1_value);
			if (dirty & /*$localization*/ 1 && t3_value !== (t3_value = /*infographics*/ ctx[1].content + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(275:4) {#each $localization.advantages.infographics as infographics, index}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div3;
	let div1;
	let div0;
	let t;
	let div2;
	let each_value_1 = /*$localization*/ ctx[0].advantages.overview;
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	let each_value = /*$localization*/ ctx[0].advantages.infographics;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t = space();
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div3 = claim_element(nodes, "DIV", { class: true, id: true });
			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "container overview svelte-15otg7s");
			add_location(div0, file$4, 263, 4, 4537);
			attr_dev(div1, "class", "overview-wrapper svelte-15otg7s");
			add_location(div1, file$4, 262, 2, 4502);
			attr_dev(div2, "class", "container");
			add_location(div2, file$4, 273, 2, 4827);
			attr_dev(div3, "class", "path svelte-15otg7s");
			attr_dev(div3, "id", "advantages");
			add_location(div3, file$4, 261, 0, 4465);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append_dev(div3, t);
			append_dev(div3, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$localization*/ 1) {
				each_value_1 = /*$localization*/ ctx[0].advantages.overview;
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div0, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (dirty & /*$localization*/ 1) {
				each_value = /*$localization*/ ctx[0].advantages.infographics;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function appear(node) {
	const io = new IntersectionObserver(([entry]) => {
			if (!entry.isIntersecting) return;
			node.classList.add("appear");
			io.unobserve(node);
		},
	{ threshold: 0.2 });

	io.observe(node);
}

function instance$4($$self, $$props, $$invalidate) {
	let $localization;
	validate_store(localization, "localization");
	component_subscribe($$self, localization, $$value => $$invalidate(0, $localization = $$value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Advantages> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Advantages", $$slots, []);
	$$self.$capture_state = () => ({ localization, appear, $localization });
	return [$localization];
}

class Advantages extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Advantages",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/components/Features.svelte generated by Svelte v3.21.0 */
const file$5 = "src/components/Features.svelte";

function create_fragment$5(ctx) {
	let div4;
	let h10;
	let t0_value = /*$localization*/ ctx[0].features.title + "";
	let t0;
	let t1;
	let div1;
	let p0;
	let t2_value = /*$localization*/ ctx[0].features.content[0] + "";
	let t2;
	let t3;
	let div0;
	let t4;
	let p1;
	let t5_value = /*$localization*/ ctx[0].features.content[1] + "";
	let t5;
	let t6;
	let h11;
	let t7_value = /*$localization*/ ctx[0].features.testBaseTitle + "";
	let t7;
	let t8;
	let div3;
	let p2;
	let t9_value = /*$localization*/ ctx[0].features.testBaseContent[0] + "";
	let t9;
	let t10;
	let div2;
	let t11;
	let p3;
	let t12_value = /*$localization*/ ctx[0].features.testBaseContent[1] + "";
	let t12;

	const block = {
		c: function create() {
			div4 = element("div");
			h10 = element("h1");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			p0 = element("p");
			t2 = text(t2_value);
			t3 = space();
			div0 = element("div");
			t4 = space();
			p1 = element("p");
			t5 = text(t5_value);
			t6 = space();
			h11 = element("h1");
			t7 = text(t7_value);
			t8 = space();
			div3 = element("div");
			p2 = element("p");
			t9 = text(t9_value);
			t10 = space();
			div2 = element("div");
			t11 = space();
			p3 = element("p");
			t12 = text(t12_value);
			this.h();
		},
		l: function claim(nodes) {
			div4 = claim_element(nodes, "DIV", { class: true, id: true });
			var div4_nodes = children(div4);
			h10 = claim_element(div4_nodes, "H1", { class: true });
			var h10_nodes = children(h10);
			t0 = claim_text(h10_nodes, t0_value);
			h10_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			p0 = claim_element(div1_nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t2 = claim_text(p0_nodes, t2_value);
			p0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t4 = claim_space(div1_nodes);
			p1 = claim_element(div1_nodes, "P", { class: true });
			var p1_nodes = children(p1);
			t5 = claim_text(p1_nodes, t5_value);
			p1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t6 = claim_space(div4_nodes);
			h11 = claim_element(div4_nodes, "H1", { class: true });
			var h11_nodes = children(h11);
			t7 = claim_text(h11_nodes, t7_value);
			h11_nodes.forEach(detach_dev);
			t8 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			p2 = claim_element(div3_nodes, "P", { class: true });
			var p2_nodes = children(p2);
			t9 = claim_text(p2_nodes, t9_value);
			p2_nodes.forEach(detach_dev);
			t10 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			children(div2).forEach(detach_dev);
			t11 = claim_space(div3_nodes);
			p3 = claim_element(div3_nodes, "P", { class: true });
			var p3_nodes = children(p3);
			t12 = claim_text(p3_nodes, t12_value);
			p3_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h10, "class", "text-primary svelte-1cvf5qm");
			add_location(h10, file$5, 59, 2, 873);
			attr_dev(p0, "class", "svelte-1cvf5qm");
			add_location(p0, file$5, 62, 4, 974);
			attr_dev(div0, "class", "split svelte-1cvf5qm");
			add_location(div0, file$5, 63, 4, 1021);
			attr_dev(p1, "class", "svelte-1cvf5qm");
			add_location(p1, file$5, 64, 4, 1047);
			attr_dev(div1, "class", "row text-secondary svelte-1cvf5qm");
			add_location(div1, file$5, 61, 2, 937);
			attr_dev(h11, "class", "text-primary svelte-1cvf5qm");
			add_location(h11, file$5, 67, 2, 1102);
			attr_dev(p2, "class", "svelte-1cvf5qm");
			add_location(p2, file$5, 70, 4, 1211);
			attr_dev(div2, "class", "split svelte-1cvf5qm");
			add_location(div2, file$5, 71, 4, 1266);
			attr_dev(p3, "class", "svelte-1cvf5qm");
			add_location(p3, file$5, 72, 4, 1292);
			attr_dev(div3, "class", "row text-secondary svelte-1cvf5qm");
			add_location(div3, file$5, 69, 2, 1174);
			attr_dev(div4, "class", "path container svelte-1cvf5qm");
			attr_dev(div4, "id", "features");
			add_location(div4, file$5, 58, 0, 828);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div4, anchor);
			append_dev(div4, h10);
			append_dev(h10, t0);
			append_dev(div4, t1);
			append_dev(div4, div1);
			append_dev(div1, p0);
			append_dev(p0, t2);
			append_dev(div1, t3);
			append_dev(div1, div0);
			append_dev(div1, t4);
			append_dev(div1, p1);
			append_dev(p1, t5);
			append_dev(div4, t6);
			append_dev(div4, h11);
			append_dev(h11, t7);
			append_dev(div4, t8);
			append_dev(div4, div3);
			append_dev(div3, p2);
			append_dev(p2, t9);
			append_dev(div3, t10);
			append_dev(div3, div2);
			append_dev(div3, t11);
			append_dev(div3, p3);
			append_dev(p3, t12);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$localization*/ 1 && t0_value !== (t0_value = /*$localization*/ ctx[0].features.title + "")) set_data_dev(t0, t0_value);
			if (dirty & /*$localization*/ 1 && t2_value !== (t2_value = /*$localization*/ ctx[0].features.content[0] + "")) set_data_dev(t2, t2_value);
			if (dirty & /*$localization*/ 1 && t5_value !== (t5_value = /*$localization*/ ctx[0].features.content[1] + "")) set_data_dev(t5, t5_value);
			if (dirty & /*$localization*/ 1 && t7_value !== (t7_value = /*$localization*/ ctx[0].features.testBaseTitle + "")) set_data_dev(t7, t7_value);
			if (dirty & /*$localization*/ 1 && t9_value !== (t9_value = /*$localization*/ ctx[0].features.testBaseContent[0] + "")) set_data_dev(t9, t9_value);
			if (dirty & /*$localization*/ 1 && t12_value !== (t12_value = /*$localization*/ ctx[0].features.testBaseContent[1] + "")) set_data_dev(t12, t12_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let $localization;
	validate_store(localization, "localization");
	component_subscribe($$self, localization, $$value => $$invalidate(0, $localization = $$value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Features> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Features", $$slots, []);
	$$self.$capture_state = () => ({ localization, $localization });
	return [$localization];
}

class Features extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Features",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src/components/Footer.svelte generated by Svelte v3.21.0 */
const file$6 = "src/components/Footer.svelte";

function create_fragment$6(ctx) {
	let footer;
	let div0;
	let a;
	let span;
	let t0_value = /*$localization*/ ctx[0].contactUs + "";
	let t0;
	let t1;
	let img;
	let img_src_value;
	let t2;
	let div1;
	let t3_value = /*$localization*/ ctx[0].copyright + "";
	let t3;

	const block = {
		c: function create() {
			footer = element("footer");
			div0 = element("div");
			a = element("a");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			img = element("img");
			t2 = space();
			div1 = element("div");
			t3 = text(t3_value);
			this.h();
		},
		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true, id: true });
			var footer_nodes = children(footer);
			div0 = claim_element(footer_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			a = claim_element(div0_nodes, "A", { class: true, href: true });
			var a_nodes = children(a);
			span = claim_element(a_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(a_nodes);
			img = claim_element(a_nodes, "IMG", { src: true, alt: true, class: true });
			a_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(footer_nodes);
			div1 = claim_element(footer_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t3 = claim_text(div1_nodes, t3_value);
			div1_nodes.forEach(detach_dev);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "text-primary svelte-b7caeg");
			add_location(span, file$6, 52, 6, 955);
			if (img.src !== (img_src_value = "/images/mail.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "mail");
			attr_dev(img, "class", "svelte-b7caeg");
			add_location(img, file$6, 53, 6, 1021);
			attr_dev(a, "class", "contact svelte-b7caeg");
			attr_dev(a, "href", "mailto:medlibra@gmail.com");
			add_location(a, file$6, 51, 4, 896);
			attr_dev(div0, "class", "contact-container svelte-b7caeg");
			add_location(div0, file$6, 50, 2, 860);
			attr_dev(div1, "class", "copyright text-secondary svelte-b7caeg");
			add_location(div1, file$6, 56, 2, 1083);
			attr_dev(footer, "class", "path svelte-b7caeg");
			attr_dev(footer, "id", "contact");
			add_location(footer, file$6, 49, 0, 823);
		},
		m: function mount(target, anchor) {
			insert_dev(target, footer, anchor);
			append_dev(footer, div0);
			append_dev(div0, a);
			append_dev(a, span);
			append_dev(span, t0);
			append_dev(a, t1);
			append_dev(a, img);
			append_dev(footer, t2);
			append_dev(footer, div1);
			append_dev(div1, t3);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$localization*/ 1 && t0_value !== (t0_value = /*$localization*/ ctx[0].contactUs + "")) set_data_dev(t0, t0_value);
			if (dirty & /*$localization*/ 1 && t3_value !== (t3_value = /*$localization*/ ctx[0].copyright + "")) set_data_dev(t3, t3_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(footer);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $localization;
	validate_store(localization, "localization");
	component_subscribe($$self, localization, $$value => $$invalidate(0, $localization = $$value));
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Footer> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Footer", $$slots, []);
	$$self.$capture_state = () => ({ localization, $localization });
	return [$localization];
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Footer",
			options,
			id: create_fragment$6.name
		});
	}
}

/* src/routes/index.svelte generated by Svelte v3.21.0 */
const file$7 = "src/routes/index.svelte";

function create_fragment$7(ctx) {
	let t0;
	let t1;
	let main;
	let t2;
	let t3;
	let t4;
	let current;
	const background = new Background({ $$inline: true });

	const header = new Header({
			props: {
				currentObservedItem: /*currentObservedItem*/ ctx[0]
			},
			$$inline: true
		});

	const download = new Download({ $$inline: true });
	const advantages = new Advantages({ $$inline: true });
	const features = new Features({ $$inline: true });
	const footer = new Footer({ $$inline: true });

	const block = {
		c: function create() {
			create_component(background.$$.fragment);
			t0 = space();
			create_component(header.$$.fragment);
			t1 = space();
			main = element("main");
			create_component(download.$$.fragment);
			t2 = space();
			create_component(advantages.$$.fragment);
			t3 = space();
			create_component(features.$$.fragment);
			t4 = space();
			create_component(footer.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(background.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(header.$$.fragment, nodes);
			t1 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(download.$$.fragment, main_nodes);
			t2 = claim_space(main_nodes);
			claim_component(advantages.$$.fragment, main_nodes);
			t3 = claim_space(main_nodes);
			claim_component(features.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			claim_component(footer.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "svelte-gbim4i");
			add_location(main, file$7, 59, 0, 1307);
		},
		m: function mount(target, anchor) {
			mount_component(background, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(header, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, main, anchor);
			mount_component(download, main, null);
			append_dev(main, t2);
			mount_component(advantages, main, null);
			append_dev(main, t3);
			mount_component(features, main, null);
			insert_dev(target, t4, anchor);
			mount_component(footer, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const header_changes = {};
			if (dirty & /*currentObservedItem*/ 1) header_changes.currentObservedItem = /*currentObservedItem*/ ctx[0];
			header.$set(header_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(background.$$.fragment, local);
			transition_in(header.$$.fragment, local);
			transition_in(download.$$.fragment, local);
			transition_in(advantages.$$.fragment, local);
			transition_in(features.$$.fragment, local);
			transition_in(footer.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(background.$$.fragment, local);
			transition_out(header.$$.fragment, local);
			transition_out(download.$$.fragment, local);
			transition_out(advantages.$$.fragment, local);
			transition_out(features.$$.fragment, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(background, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(header, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(main);
			destroy_component(download);
			destroy_component(advantages);
			destroy_component(features);
			if (detaching) detach_dev(t4);
			destroy_component(footer, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let currentObservedItem = null;

	function observe() {
		const observedItems = new Map();

		function callback(entries) {
			for (const entry of entries) {
				observedItems.set(entry.target.getAttribute("id"), entry.isIntersecting);
			}

			const next = [...observedItems.entries()].reverse().find(([_, i]) => i);

			if (next && next[0]) {
				$$invalidate(0, currentObservedItem = next[0]);
			}
		}

		const io = new IntersectionObserver(callback, { threshold: 0.2 });
		const nodes = document.querySelectorAll(".path");

		for (const node of [...nodes]) {
			observedItems.set(node.getAttribute("id"), false);
			io.observe(node);
		}
	}

	onMount(() => {
		observe();
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Routes", $$slots, []);

	$$self.$capture_state = () => ({
		onMount,
		Header,
		Background,
		Download,
		Advantages,
		Features,
		Footer,
		currentObservedItem,
		observe
	});

	$$self.$inject_state = $$props => {
		if ("currentObservedItem" in $$props) $$invalidate(0, currentObservedItem = $$props.currentObservedItem);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [currentObservedItem];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$7.name
		});
	}
}

export default Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYjMzNmUwODYuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9pY29ucy9BcnJvdy5zdmciLCIuLi8uLi8uLi9zcmMvbG9jYWxpemF0aW9uL2luZGV4LmpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvSGVhZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0JhY2tncm91bmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvRG93bmxvYWQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQWR2YW50YWdlcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9GZWF0dXJlcy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9Gb290ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG48cGF0aCBkPVwiTTAgNEgxNkw4IDE2TDAgNFpcIiBmaWxsPVwiIzczMUREOFwiLz5cbjwvc3ZnPlxuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuaW1wb3J0IHVhIGZyb20gJy4vbG9jYWxlcy91YS5qc29uJztcblxuY29uc3QgZ2xvYmFsID0gZ2xvYmFsVGhpcyB8fCB3aW5kb3cgfHwgZ2xvYmFsO1xuXG5jb25zdCBLRVkgPSAnY3VycmVudExhbmd1YWdlJztcbmNvbnN0IGNhY2hlID0geyB1YSB9O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZSkge1xuICBjb25zdCBuZXh0TG9jYWxlID1cbiAgICBjYWNoZVtsb2NhbGVdIHx8IChhd2FpdCAoYXdhaXQgZmV0Y2goYC9sb2NhbGVzLyR7bG9jYWxlfS5qc29uYCkpLmpzb24oKSk7XG4gIGxvY2FsaXphdGlvbi5zZXQobmV4dExvY2FsZSk7XG4gIGNhY2hlW2xvY2FsZV0gPSBuZXh0TG9jYWxlO1xuICBnbG9iYWwubG9jYWxTdG9yYWdlICYmIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShLRVksIGxvY2FsZSk7XG59XG5cbmlmICghIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgY29uc3QgaW5pdGlhbExhbmd1YWdlID0gZ2xvYmFsLmxvY2FsU3RvcmFnZS5nZXRJdGVtKEtFWSk7XG5cbiAgaWYgKGluaXRpYWxMYW5ndWFnZSAhPT0gJ3VhJyAmJiBpbml0aWFsTGFuZ3VhZ2UgIT09IG51bGwpIHtcbiAgICBzZXRMb2NhbGUoaW5pdGlhbExhbmd1YWdlKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbG9jYWxpemF0aW9uID0gd3JpdGFibGUodWEpO1xuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IEFycm93IGZyb20gJy4uL2ljb25zL0Fycm93LnN2Zyc7XG4gIGltcG9ydCB7IHNldExvY2FsZSwgbG9jYWxpemF0aW9uIH0gZnJvbSAnLi4vbG9jYWxpemF0aW9uJztcblxuICBleHBvcnQgbGV0IGN1cnJlbnRPYnNlcnZlZEl0ZW07XG5cbiAgJDogbWVudUl0ZW1zID0gW1xuICAgIHsgbGluazogJyNkb3dubG9hZCcsIHRpdGxlOiAkbG9jYWxpemF0aW9uLm1lbnUuZG93bmxvYWQgfSxcbiAgICB7IGxpbms6ICcjYWR2YW50YWdlcycsIHRpdGxlOiAkbG9jYWxpemF0aW9uLm1lbnUuYWR2YW50YWdlcyB9LFxuICAgIHsgbGluazogJyNmZWF0dXJlcycsIHRpdGxlOiAkbG9jYWxpemF0aW9uLm1lbnUuZmVhdHVyZXMgfSxcbiAgICB7IGxpbms6ICcjY29udGFjdCcsIHRpdGxlOiAkbG9jYWxpemF0aW9uLm1lbnUuY29udGFjdCB9LFxuICBdO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgaW1nIHtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG5cbiAgaGVhZGVyIHtcbiAgICB0b3A6IDA7XG4gICAgei1pbmRleDogMjtcbiAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgIGJhY2tncm91bmQ6ICMxYTFkMWQ7XG4gICAgcGFkZGluZzogMTJweCAwO1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgfVxuXG4gIC5jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICAgIC8qIHdpZHRoOiAxMDAlOyAqL1xuICB9XG5cbiAgLnNlZ21lbnQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB3aWR0aDogNTAlO1xuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICBoZWFkZXIge1xuICAgICAgcGFkZGluZy10b3A6IDhweDtcbiAgICB9XG5cbiAgICAubG9nbyB7XG4gICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgfVxuXG4gICAgLnNlZ21lbnQge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuXG4gICAgLm1haW4ge1xuICAgICAgbWFyZ2luLWJvdHRvbTogMTJweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMDIzcHgpIHtcbiAgICBoZWFkZXIge1xuICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgIH1cblxuICAgIC5tYWluIHtcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICB9XG5cbiAgICAubWVudSA6Z2xvYmFsKGFbaHJlZj0nI2ZlYXR1cmVzJ10pIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTAyNHB4KSB7XG4gICAgLm1lbnUge1xuICAgICAgZmxleDogMTtcbiAgICAgIG1heC13aWR0aDogNjUycHg7XG4gICAgfVxuXG4gICAgLnNlZ21lbnQge1xuICAgICAgd2lkdGg6IGF1dG87XG4gICAgfVxuXG4gICAgLmNvbnRhaW5lciB7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICAubWVudSB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgcGFkZGluZy1sZWZ0OiAzMnB4O1xuICAgIH1cbiAgfVxuXG4gIC5tZW51IGEge1xuICAgIHRyYW5zaXRpb246IGNvbG9yIDE1MG1zO1xuICB9XG5cbiAgLm1lbnUgYS5hY3RpdmUge1xuICAgIGNvbG9yOiAjZmVmYmY2O1xuICB9XG5cbiAgLmhvbWUge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gIH1cblxuICAubGFuZ3VhZ2Uge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgcGFkZGluZy1ib3R0b206IDRweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1hcmdpbi1sZWZ0OiA0NHB4O1xuICAgIG91dGxpbmU6IDA7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG5cbiAgLmxhbmd1YWdlIHNwYW4ge1xuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIGxpbmUtaGVpZ2h0OiAyOHB4O1xuICAgIG1hcmdpbi1yaWdodDogNXB4O1xuICB9XG5cbiAgLmxhbmd1YWdlIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDE1MG1zO1xuICB9XG5cbiAgLmxhbmd1YWdlOmZvY3VzIDpnbG9iYWwoc3ZnKSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKSB0cmFuc2xhdGVZKC00cHgpO1xuICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gIH1cblxuICAubGFuZ3VhZ2U6bm90KDpmb2N1cykgLmxhbmd1YWdlLXNlbGVjdCB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cblxuICAubGFuZ3VhZ2U6bm90KDpmb2N1cykgLmxhbmd1YWdlLW92ZXJsYXkge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cblxuICAubGFuZ3VhZ2UgLmxhbmd1YWdlLW92ZXJsYXkge1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gICAgb3V0bGluZTogMDtcbiAgfVxuXG4gIC5sYW5ndWFnZS1zZWxlY3Qge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDEwMCU7XG4gICAgcmlnaHQ6IDA7XG4gICAgdHJhbnNpdGlvbjogYWxsIDE1MG1zO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtOHB4KTtcbiAgICBvcGFjaXR5OiAwO1xuICAgIGJhY2tncm91bmQ6ICMxYTFkMWQ7XG4gICAgYm9yZGVyOiAycHggc29saWQgIzczMWRkODtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICBwYWRkaW5nOiA4cHg7XG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcbiAgfVxuXG4gIC5sYW5ndWFnZS1zZWxlY3QgPiBkaXY6bm90KDpudGgtbGFzdC1jaGlsZCgxKSkge1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gIH1cblxuICAubGFuZ3VhZ2U6Zm9jdXMgLmxhbmd1YWdlLXNlbGVjdCB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XG4gIH1cblxuICAubWVudSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIH1cblxuICAubWVudSBhIHtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICBsZXR0ZXItc3BhY2luZzogMC4wMDI1ZW07XG4gICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gIH1cbjwvc3R5bGU+XG5cbjxoZWFkZXI+XG4gIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2VnbWVudCBtYWluXCI+XG4gICAgICA8YSBjbGFzcz1cImhvbWVcIiBocmVmPVwiL1wiPlxuICAgICAgICA8aW1nIGNsYXNzPVwibG9nb1wiIHNyYz1cIi9pbWFnZXMvTG9nby5zdmdcIiBhbHQ9XCJtZWRsaWJyYVwiIC8+XG4gICAgICA8L2E+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJsYW5ndWFnZSB0ZXh0LXNlY29uZGFyeVwiIGhyZWY9XCIvXCIgdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsYW5ndWFnZS1vdmVybGF5XCIgdGFiaW5kZXg9XCIwXCIgLz5cbiAgICAgICAgPHNwYW4+eyRsb2NhbGl6YXRpb24uY3VycmVudExhbmd1YWdlfTwvc3Bhbj5cbiAgICAgICAgPEFycm93IC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsYW5ndWFnZS1zZWxlY3RcIiB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgICB7I2VhY2ggJGxvY2FsaXphdGlvbi5sYW5ndWFnZXMgYXMgbGFuZ3VhZ2V9XG4gICAgICAgICAgICA8ZGl2IG9uOm1vdXNlZG93bj17KCkgPT4gc2V0TG9jYWxlKGxhbmd1YWdlLmtleSl9PlxuICAgICAgICAgICAgICB7bGFuZ3VhZ2UubmFtZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzZWdtZW50IG1lbnVcIj5cbiAgICAgIHsjZWFjaCBtZW51SXRlbXMgYXMgaXRlbX1cbiAgICAgICAgPGFcbiAgICAgICAgICBjbGFzcz1cInRleHQtaW5hY3RpdmVcIlxuICAgICAgICAgIGNsYXNzOmFjdGl2ZT17aXRlbS5saW5rID09PSBgIyR7Y3VycmVudE9ic2VydmVkSXRlbX1gfVxuICAgICAgICAgIGhyZWY9e2l0ZW0ubGlua30+XG4gICAgICAgICAge2l0ZW0udGl0bGV9XG4gICAgICAgIDwvYT5cbiAgICAgIHsvZWFjaH1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2hlYWRlcj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGxldCBtb3VudGVkID0gZmFsc2U7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBtb3VudGVkID0gdHJ1ZTtcbiAgICB9LCAyMDApO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5iYWNrZ3JvdW5kIHtcbiAgICB0b3A6IDA7XG4gICAgbGVmdDogMDtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cblxuICAuYmFja2dyb3VuZCAuZGFyayB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC00OHB4KTtcbiAgfVxuXG4gIC5iYWNrZ3JvdW5kIC5saWdodCB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDQ4cHgpO1xuICB9XG5cbiAgLmJhY2tncm91bmQubW91bnRlZCBpbWcge1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG5cbiAgaW1nIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgb3BhY2l0eTogMDtcbiAgICB0cmFuc2l0aW9uOiBhbGwgNjAwbXM7XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzNTlweCkge1xuICAgIGltZyB7XG4gICAgICB3aWR0aDogMzYwcHg7XG4gICAgfVxuXG4gICAgLmxpZ2h0IHtcbiAgICAgIGxlZnQ6IDk2cHg7XG4gICAgICB0b3A6IDQ2NHB4O1xuICAgIH1cblxuICAgIC5kYXJrIHtcbiAgICAgIGxlZnQ6IDE2MHB4O1xuICAgICAgdG9wOiAzODBweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAzNjBweCkgYW5kIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgaW1nIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIC5saWdodCB7XG4gICAgICB0b3A6IDQ1MnB4O1xuICAgICAgbGVmdDogMDtcbiAgICB9XG5cbiAgICAuZGFyayB7XG4gICAgICB0b3A6IDM2NHB4O1xuICAgICAgbGVmdDogNjRweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkge1xuICAgIGltZyB7XG4gICAgICBoZWlnaHQ6IDYwMHB4O1xuICAgIH1cblxuICAgIC5kYXJrIHtcbiAgICAgIHRvcDogMDtcbiAgICAgIGxlZnQ6IGNhbGMoNTAlICsgMTE0cHgpO1xuICAgIH1cblxuICAgIC5saWdodCB7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0b3A6IDI3MnB4O1xuICAgIH1cbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImJhY2tncm91bmRcIiBjbGFzczptb3VudGVkPlxuICA8aW1nIGNsYXNzPVwibGlnaHRcIiBzcmM9XCIvaW1hZ2VzL2xpZ2h0LnBuZ1wiIGFsdD1cImxpZ2h0XCIgLz5cbiAgPGltZyBjbGFzcz1cImRhcmtcIiBzcmM9XCIvaW1hZ2VzL2RhcmsucG5nXCIgYWx0PVwiZGFya1wiIC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGxvY2FsaXphdGlvbiB9IGZyb20gJy4uL2xvY2FsaXphdGlvbic7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBzdmcsXG4gIGltZyB7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuXG4gIGgxIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogNjRweDtcbiAgfVxuXG4gIGgzIHtcbiAgICBwYWRkaW5nLWJvdHRvbTogMzJweDtcbiAgfVxuXG4gIC5jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgfVxuXG4gIC5kb3dubG9hZC1idXR0b25zIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICB9XG5cbiAgLmRvd25sb2FkLWJ1dHRvbnMgYSB7XG4gICAgd2lkdGg6IDE5NnB4O1xuICB9XG5cbiAgLmRvd25sb2FkLWJ1dHRvbnMgYTpub3QoOm50aC1sYXN0LWNoaWxkKDEpKSB7XG4gICAgbWFyZ2luLXJpZ2h0OiAzMnB4O1xuICB9XG5cbiAgLmRvd25sb2FkLWJ1dHRvbnMgYSB7XG4gICAgcGFkZGluZzogMjBweCAwO1xuICAgIHBhZGRpbmctbGVmdDogMTZweDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIG91dGxpbmU6IDA7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgd2lkdGg6IDE5NnB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cblxuICAuZG93bmxvYWQtYnV0dG9ucyBhIC5ib3JkZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgdG9wOiAwO1xuICAgIGxlZnQ6IDA7XG4gIH1cblxuICAuZG93bmxvYWQtYnV0dG9ucyBhIC5jb250ZW50IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHdpZHRoOiAxMDAlO1xuICB9XG5cbiAgLmRvd25sb2FkLWJ1dHRvbnMgYSAudGV4dC1jb250ZW50IHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB9XG5cbiAgLnRleHQtYWNjZW50IHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzNTlweCkge1xuICAgIC5kb3dubG9hZC1idXR0b25zIHtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgfVxuXG4gICAgLmRvd25sb2FkLWJ1dHRvbnMgYTpudGgtY2hpbGQoMSkge1xuICAgICAgbWFyZ2luLWJvdHRvbTogMjZweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xuICAgIGgxIHtcbiAgICAgIG1heC13aWR0aDogMzI4cHg7XG4gICAgICBwYWRkaW5nLWJvdHRvbTogMzJweDtcbiAgICB9XG5cbiAgICAuZG93bmxvYWQtYnV0dG9ucyBhIHtcbiAgICAgIHdpZHRoOiAxNTZweDtcbiAgICB9XG5cbiAgICAuY29udGFpbmVyIHtcbiAgICAgIGhlaWdodDogNTcycHg7XG4gICAgICBwYWRkaW5nLXRvcDogMzJweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xuICAgIGgxIHtcbiAgICAgIG1heC13aWR0aDogMzI4cHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTI4MHB4KSB7XG4gICAgaDEge1xuICAgICAgbWF4LXdpZHRoOiA4NzZweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjhweCkgYW5kIChtYXgtd2lkdGg6IDEyNzlweCkge1xuICAgIGgxIHtcbiAgICAgIG1heC13aWR0aDogNjUwcHg7XG4gICAgfVxuXG4gICAgLmNvbnRhaW5lciB7XG4gICAgICBoZWlnaHQ6IDY1NnB4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTI4MHB4KSB7XG4gICAgLmNvbnRhaW5lciB7XG4gICAgICBoZWlnaHQ6IDcwNHB4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICBoMSB7XG4gICAgICBwYWRkaW5nLWJvdHRvbTogNjRweDtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJwYXRoIGNvbnRhaW5lclwiIGlkPVwiZG93bmxvYWRcIj5cbiAgPGgxIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+XG4gICAgeyRsb2NhbGl6YXRpb24uZG93bmxvYWQudGl0bGV9XG4gICAgPGJyIC8+XG4gICAgPGJyIC8+XG4gICAgeyRsb2NhbGl6YXRpb24uZG93bmxvYWQudGl0bGVEZXNjcmlwdGlvbn1cbiAgPC9oMT5cblxuICA8aDMgY2xhc3M9XCJ0ZXh0LXNlY29uZGFyeVwiPnskbG9jYWxpemF0aW9uLmRvd25sb2FkLmRvd25sb2FkRnJlZX08L2gzPlxuXG4gIDxkaXYgY2xhc3M9XCJkb3dubG9hZC1idXR0b25zXCI+XG4gICAgPGEgaHJlZj1cIi9cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJib3JkZXJcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XG4gICAgICAgICAgPGRlZnM+XG4gICAgICAgICAgICA8bGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgICAgaWQ9XCJncmFkaWVudC1hcHBzdG9yZVwiXG4gICAgICAgICAgICAgIHgxPVwiMCVcIlxuICAgICAgICAgICAgICB5MT1cIjAlXCJcbiAgICAgICAgICAgICAgeDI9XCIxMDAlXCJcbiAgICAgICAgICAgICAgeTI9XCIwJVwiPlxuICAgICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCIjMUFDNkZCXCIgLz5cbiAgICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCIjMUM3MkYwXCIgLz5cbiAgICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgICAgPC9kZWZzPlxuICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICB4PVwiMVwiXG4gICAgICAgICAgICB5PVwiMVwiXG4gICAgICAgICAgICByeD1cIjE2XCJcbiAgICAgICAgICAgIHJ5PVwiMTZcIlxuICAgICAgICAgICAgd2lkdGg9XCJjYWxjKDEwMCUgLSAycHgpXCJcbiAgICAgICAgICAgIGZpbGw9XCJyZ2JhKDI1NCwgMjUxLCAyNDYsIDAuMDUpXCJcbiAgICAgICAgICAgIGhlaWdodD1cImNhbGMoMTAwJSAtIDJweClcIlxuICAgICAgICAgICAgc3Ryb2tlPVwidXJsKCNncmFkaWVudC1hcHBzdG9yZSlcIlxuICAgICAgICAgICAgc3Ryb2tlLXdpZHRoPVwiMlwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgIDxpbWcgc3JjPVwiL2ltYWdlcy9hcHBzdG9yZS5zdmdcIiBhbHQ9XCJhcHAgc3RvcmVcIiAvPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jb250ZW50XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0LWFjY2VudCB0ZXh0LXByaW1hcnlcIj5BcHBTdG9yZTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2E+XG5cbiAgICA8YSBocmVmPVwiL1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImJvcmRlclwiPlxuICAgICAgICA8c3ZnIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj5cbiAgICAgICAgICA8ZGVmcz5cbiAgICAgICAgICAgIDxsaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgICBpZD1cImdyYWRpZW50LXBsYXltYXJrZXRcIlxuICAgICAgICAgICAgICB4MT1cIjAlXCJcbiAgICAgICAgICAgICAgeTE9XCIwJVwiXG4gICAgICAgICAgICAgIHgyPVwiMTAwJVwiXG4gICAgICAgICAgICAgIHkyPVwiMCVcIj5cbiAgICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVwiMCVcIiBzdG9wLWNvbG9yPVwiIzAwRTBGRlwiIC8+XG4gICAgICAgICAgICAgIDxzdG9wIG9mZnNldD1cIjMzJVwiIHN0b3AtY29sb3I9XCIjMDBGMDg1XCIgLz5cbiAgICAgICAgICAgICAgPHN0b3Agb2Zmc2V0PVwiNjYlXCIgc3RvcC1jb2xvcj1cIiNGRkUzMDBcIiAvPlxuICAgICAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIxMDAlXCIgc3RvcC1jb2xvcj1cIiNGRjRFNTRcIiAvPlxuICAgICAgICAgICAgPC9saW5lYXJHcmFkaWVudD5cbiAgICAgICAgICA8L2RlZnM+XG4gICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgIHg9XCIxXCJcbiAgICAgICAgICAgIHk9XCIxXCJcbiAgICAgICAgICAgIHJ4PVwiMTZcIlxuICAgICAgICAgICAgcnk9XCIxNlwiXG4gICAgICAgICAgICB3aWR0aD1cImNhbGMoMTAwJSAtIDJweClcIlxuICAgICAgICAgICAgZmlsbD1cInJnYmEoMjU0LCAyNTEsIDI0NiwgMC4wNSlcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiY2FsYygxMDAlIC0gMnB4KVwiXG4gICAgICAgICAgICBzdHJva2U9XCJ1cmwoI2dyYWRpZW50LXBsYXltYXJrZXQpXCJcbiAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIjJcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICA8aW1nIHNyYz1cIi9pbWFnZXMvcGxheXN0b3JlLnN2Z1wiIGFsdD1cInBsYXkgbWFya2V0XCIgLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtY29udGVudFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1hY2NlbnQgdGV4dC1wcmltYXJ5XCI+UGxheU1hcmtldDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2E+XG4gIDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBsb2NhbGl6YXRpb24gfSBmcm9tICcuLi9sb2NhbGl6YXRpb24nO1xuXG4gIGZ1bmN0aW9uIGFwcGVhcihub2RlKSB7XG4gICAgY29uc3QgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoW2VudHJ5XSkgPT4ge1xuICAgICAgICBpZiAoIWVudHJ5LmlzSW50ZXJzZWN0aW5nKSByZXR1cm47XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYXBwZWFyJyk7XG4gICAgICAgIGlvLnVub2JzZXJ2ZShub2RlKTtcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRocmVzaG9sZDogMC4yLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgaW8ub2JzZXJ2ZShub2RlKTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLyogb3ZlcnZpZXcgKi9cbiAgLm92ZXJ2aWV3IHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG5cbiAgLm92ZXJ2aWV3LXdyYXBwZXIge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIH1cblxuICAub3ZlcnZpZXcuY29udGFpbmVyIHtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG5cbiAgLm92ZXJ2aWV3IGgyLFxuICAub3ZlcnZpZXcgaDMge1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtbGluZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIH1cblxuICAub3ZlcnZpZXcgaDIge1xuICAgIHBhZGRpbmctYm90dG9tOiA4cHg7XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA3NjdweCkge1xuICAgIC5vdmVydmlldyB7XG4gICAgICBoZWlnaHQ6IDQ2NHB4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAub3ZlcnZpZXcgLml0ZW0ge1xuICAgICAgd2lkdGg6IDUwJTtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA3NjdweCkgYW5kIChtYXgtd2lkdGg6IDEwMjNweCkge1xuICAgIC5vdmVydmlldyB7XG4gICAgICBoZWlnaHQ6IDM0NHB4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAub3ZlcnZpZXcuY29udGFpbmVyIHtcbiAgICAgIC8qIG1heC13aWR0aDogMTAwJTsgKi9cbiAgICAgIHBhZGRpbmc6IDAgMTJweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxMDI0cHgpIHtcbiAgICAub3ZlcnZpZXc6YmVmb3JlLFxuICAgIC5vdmVydmlldzphZnRlciB7XG4gICAgICBjb250ZW50OiAnJztcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgbGVmdDogLTEwMCU7XG4gICAgICBoZWlnaHQ6IDRweDtcbiAgICAgIG1hcmdpbi10b3A6IC0ycHg7XG4gICAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NCwgMjUxLCAyNDYsIDAuMTUpO1xuICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgICAgdG9wOiA1MCU7XG4gICAgfVxuXG4gICAgLm92ZXJ2aWV3OmJlZm9yZSB7XG4gICAgICBsZWZ0OiAtMTAwJTtcbiAgICB9XG5cbiAgICAub3ZlcnZpZXc6YWZ0ZXIge1xuICAgICAgbGVmdDogMTAwJTtcbiAgICB9XG5cbiAgICAub3ZlcnZpZXcgLml0ZW0ge1xuICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTQsIDI1MSwgMjQ2LCAwLjEwNSk7XG4gICAgICBib3JkZXI6IDRweCBzb2xpZCByZ2JhKDI1NCwgMjUxLCAyNDYsIDAuMTA1KTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDMycHg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEwMjRweCkgYW5kIChtYXgtd2lkdGg6IDEyNzlweCkge1xuICAgIC5vdmVydmlldyB7XG4gICAgICBoZWlnaHQ6IDM0NHB4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAub3ZlcnZpZXcgLml0ZW0ge1xuICAgICAgd2lkdGg6IDE5NnB4O1xuICAgICAgaGVpZ2h0OiAyMDBweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxMjgwcHgpIGFuZCAobWF4LXdpZHRoOiAxOTE5cHgpIHtcbiAgICAub3ZlcnZpZXcge1xuICAgICAgaGVpZ2h0OiA0NzJweDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuXG4gICAgLm92ZXJ2aWV3IC5pdGVtIHtcbiAgICAgIHdpZHRoOiAyNTZweDtcbiAgICAgIGhlaWdodDogMjU2cHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTkyMHB4KSB7XG4gICAgLm92ZXJ2aWV3IHtcbiAgICAgIGhlaWdodDogNDcycHg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cblxuICAgIC5vdmVydmlldyAuaXRlbSB7XG4gICAgICB3aWR0aDogMzEwcHg7XG4gICAgICBoZWlnaHQ6IDI1NnB4O1xuICAgIH1cbiAgfVxuXG4gIC8qIGluZm9ncmFwaGljcyAqL1xuICAuaW5mb2dyYXBoaWNzIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG5cbiAgLmluZm9ncmFwaGljcyBpbWcge1xuICAgIHRyYW5zaXRpb246IGFsbCAxLjVzO1xuICB9XG5cbiAgLmluZm9ncmFwaGljczpub3QoOm50aC1sYXN0LWNoaWxkKDEpKTphZnRlciB7XG4gICAgY29udGVudDogJyc7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICAgIHdpZHRoOiA1MCU7XG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xuICAgIGhlaWdodDogNHB4O1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU0LCAyNTEsIDI0NiwgMC4xNSk7XG4gICAgbWFyZ2luLWxlZnQ6IDI1JTtcbiAgfVxuXG4gIC5pbmZvZ3JhcGhpY3M6bnRoLWNoaWxkKDJuKSB7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICB9XG5cbiAgLmluZm9ncmFwaGljcyA+ICoge1xuICAgIHdpZHRoOiA1MCU7XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAzNTlweCkge1xuICAgIC5pbmZvZ3JhcGhpY3MgaDIge1xuICAgICAgcGFkZGluZy1ib3R0b206IDhweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAzNjBweCkgYW5kIChtYXgtd2lkdGg6IDEyNzlweCkge1xuICAgIC5pbmZvZ3JhcGhpY3MgaDIge1xuICAgICAgcGFkZGluZy1ib3R0b206IDMycHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICAuaW5mb2dyYXBoaWNzIGltZyB7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC02NHB4KTtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzIDpnbG9iYWwoaW1nLmFwcGVhcikge1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzIHtcbiAgICAgIHBhZGRpbmc6IDMycHggMDtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzOm50aC1jaGlsZChuKSB7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzOm50aC1jaGlsZChuKSAqIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgIH1cblxuICAgIC5pbmZvZ3JhcGhpY3MgaW1nIHtcbiAgICAgIG1hcmdpbi1ib3R0b206IDMycHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNzY4cHgpIHtcbiAgICAuaW5mb2dyYXBoaWNzIGltZyB7XG4gICAgICB0cmFuc2l0aW9uOiBhbGwgMXM7XG4gICAgfVxuXG4gICAgLmluZm9ncmFwaGljcyBpbWcge1xuICAgICAgb3BhY2l0eTogMDtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzOm50aC1jaGlsZCgybikgaW1nIHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCg2NHB4KTtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzOm50aC1jaGlsZCgybiArIDEpIGltZyB7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTY0cHgpO1xuICAgIH1cblxuICAgIC5pbmZvZ3JhcGhpY3MgOmdsb2JhbChpbWcuYXBwZWFyKSB7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDc2OHB4KSBhbmQgKG1heC13aWR0aDogMTI3OXB4KSB7XG4gICAgLmluZm9ncmFwaGljcyB7XG4gICAgICBoZWlnaHQ6IDM1MnB4O1xuICAgIH1cblxuICAgIGgzIHtcbiAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgIGxpbmUtaGVpZ2h0OiAzMnB4O1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEyODBweCkge1xuICAgIC5pbmZvZ3JhcGhpY3Mge1xuICAgICAgaGVpZ2h0OiA0NDhweDtcbiAgICB9XG5cbiAgICAuaW5mb2dyYXBoaWNzIGgyIHtcbiAgICAgIHBhZGRpbmctYm90dG9tOiA0MHB4O1xuICAgIH1cblxuICAgIGgzIHtcbiAgICAgIGZvbnQtc2l6ZTogMzJweDtcbiAgICAgIGxpbmUtaGVpZ2h0OiA0OHB4O1xuICAgIH1cbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInBhdGhcIiBpZD1cImFkdmFudGFnZXNcIj5cbiAgPGRpdiBjbGFzcz1cIm92ZXJ2aWV3LXdyYXBwZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIG92ZXJ2aWV3XCI+XG4gICAgICB7I2VhY2ggJGxvY2FsaXphdGlvbi5hZHZhbnRhZ2VzLm92ZXJ2aWV3IGFzIG92ZXJ2aWV3fVxuICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbVwiPlxuICAgICAgICAgIDxoMiBjbGFzcz1cInRleHQtcHJpbWFyeVwiPntvdmVydmlldy50aXRsZX08L2gyPlxuICAgICAgICAgIDxoMyBjbGFzcz1cInRleHQtc2Vjb25kYXJ5XCI+e292ZXJ2aWV3LmNvbnRlbnR9PC9oMz5cbiAgICAgICAgPC9kaXY+XG4gICAgICB7L2VhY2h9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICB7I2VhY2ggJGxvY2FsaXphdGlvbi5hZHZhbnRhZ2VzLmluZm9ncmFwaGljcyBhcyBpbmZvZ3JhcGhpY3MsIGluZGV4fVxuICAgICAgPGRpdiBjbGFzcz1cImluZm9ncmFwaGljc1wiPlxuICAgICAgICA8aW1nIHVzZTphcHBlYXIgc3JjPVwiL2ltYWdlcy9pbGx1c3RyYXRpb257aW5kZXggKyAxfS5zdmdcIiBhbHQ9XCJpbWdcIiAvPlxuXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGgyIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+e2luZm9ncmFwaGljcy50aXRsZX08L2gyPlxuICAgICAgICAgIDxoMyBjbGFzcz1cInRleHQtc2Vjb25kYXJ5XCI+e2luZm9ncmFwaGljcy5jb250ZW50fTwvaDM+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgey9lYWNofVxuICA8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgbG9jYWxpemF0aW9uIH0gZnJvbSAnLi4vbG9jYWxpemF0aW9uJztcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIGgxIHtcbiAgICBwYWRkaW5nOiAzMnB4IDA7XG4gIH1cblxuICAucm93IHtcbiAgICB3aGl0ZS1zcGFjZTogcHJlLWxpbmU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgfVxuXG4gIC5zcGxpdCB7XG4gICAgd2lkdGg6IDMycHg7XG4gICAgaGVpZ2h0OiAzMnB4O1xuICB9XG5cbiAgLnJvdyBwIHtcbiAgICBmbGV4OiAxO1xuICB9XG5cbiAgLmNvbnRhaW5lciB7XG4gICAgcGFkZGluZy1ib3R0b206IDMycHg7XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiAxMjc5cHgpIHtcbiAgICAucm93IHtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTAyNHB4KSB7XG4gICAgaDEge1xuICAgICAgcGFkZGluZzogNzJweCAwO1xuICAgIH1cbiAgfVxuXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDEwMjRweCkgYW5kIChtYXgtd2lkdGg6IDEyNzlweCkge1xuICAgIC5jb250YWluZXIge1xuICAgICAgcGFkZGluZy1ib3R0b206IDU2cHg7XG4gICAgfVxuICB9XG5cbiAgQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogMTI4MHB4KSBhbmQgKG1heC13aWR0aDogMTkxOXB4KSB7XG4gICAgLmNvbnRhaW5lciB7XG4gICAgICBwYWRkaW5nLWJvdHRvbTogNzJweDtcbiAgICB9XG4gIH1cblxuICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiAxOTIwcHgpIHtcbiAgICAuY29udGFpbmVyIHtcbiAgICAgIHBhZGRpbmctYm90dG9tOiAxMDRweDtcbiAgICB9XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJwYXRoIGNvbnRhaW5lclwiIGlkPVwiZmVhdHVyZXNcIj5cbiAgPGgxIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+eyRsb2NhbGl6YXRpb24uZmVhdHVyZXMudGl0bGV9PC9oMT5cblxuICA8ZGl2IGNsYXNzPVwicm93IHRleHQtc2Vjb25kYXJ5XCI+XG4gICAgPHA+eyRsb2NhbGl6YXRpb24uZmVhdHVyZXMuY29udGVudFswXX08L3A+XG4gICAgPGRpdiBjbGFzcz1cInNwbGl0XCIgLz5cbiAgICA8cD57JGxvY2FsaXphdGlvbi5mZWF0dXJlcy5jb250ZW50WzFdfTwvcD5cbiAgPC9kaXY+XG5cbiAgPGgxIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+eyRsb2NhbGl6YXRpb24uZmVhdHVyZXMudGVzdEJhc2VUaXRsZX08L2gxPlxuXG4gIDxkaXYgY2xhc3M9XCJyb3cgdGV4dC1zZWNvbmRhcnlcIj5cbiAgICA8cD57JGxvY2FsaXphdGlvbi5mZWF0dXJlcy50ZXN0QmFzZUNvbnRlbnRbMF19PC9wPlxuICAgIDxkaXYgY2xhc3M9XCJzcGxpdFwiIC8+XG4gICAgPHA+eyRsb2NhbGl6YXRpb24uZmVhdHVyZXMudGVzdEJhc2VDb250ZW50WzFdfTwvcD5cbiAgPC9kaXY+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGxvY2FsaXphdGlvbiB9IGZyb20gJy4uL2xvY2FsaXphdGlvbic7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBpbWcge1xuICAgIG9wYWNpdHk6IDE7XG4gIH1cblxuICBmb290ZXIge1xuICAgIGJhY2tncm91bmQ6ICMxYTFkMWQ7XG4gIH1cblxuICAuY29udGFjdC1jb250YWluZXIge1xuICAgIHBhZGRpbmc6IDU2cHggMDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB9XG5cbiAgLmNvbnRhY3Qge1xuICAgIHdpZHRoOiAyNjBweDtcbiAgICBoZWlnaHQ6IDY0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTZweDtcbiAgICBib3JkZXI6IDJweCBzb2xpZCAjZmVmYmY2O1xuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU0LCAyNTEsIDI0NiwgMC4wNSk7XG4gICAgb3V0bGluZTogMDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIHBhZGRpbmc6IDAgMTZweDtcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuXG4gIC5jb250YWN0IHNwYW4ge1xuICAgIGZvbnQtZmFtaWx5OiBJQk0gUGxleCBTYW5zO1xuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgICBmb250LXdlaWdodDogNTAwO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICBsZXR0ZXItc3BhY2luZzogMC4wMDVlbTtcbiAgfVxuXG4gIC5jb3B5cmlnaHQge1xuICAgIHBhZGRpbmctYm90dG9tOiAxNnB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuPC9zdHlsZT5cblxuPGZvb3RlciBjbGFzcz1cInBhdGhcIiBpZD1cImNvbnRhY3RcIj5cbiAgPGRpdiBjbGFzcz1cImNvbnRhY3QtY29udGFpbmVyXCI+XG4gICAgPGEgY2xhc3M9XCJjb250YWN0XCIgaHJlZj1cIm1haWx0bzptZWRsaWJyYUBnbWFpbC5jb21cIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidGV4dC1wcmltYXJ5XCI+eyRsb2NhbGl6YXRpb24uY29udGFjdFVzfTwvc3Bhbj5cbiAgICAgIDxpbWcgc3JjPVwiL2ltYWdlcy9tYWlsLnN2Z1wiIGFsdD1cIm1haWxcIiAvPlxuICAgIDwvYT5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJjb3B5cmlnaHQgdGV4dC1zZWNvbmRhcnlcIj57JGxvY2FsaXphdGlvbi5jb3B5cmlnaHR9PC9kaXY+XG48L2Zvb3Rlcj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgSGVhZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvSGVhZGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBCYWNrZ3JvdW5kIGZyb20gJy4uL2NvbXBvbmVudHMvQmFja2dyb3VuZC5zdmVsdGUnO1xuICBpbXBvcnQgRG93bmxvYWQgZnJvbSAnLi4vY29tcG9uZW50cy9Eb3dubG9hZC5zdmVsdGUnO1xuICBpbXBvcnQgQWR2YW50YWdlcyBmcm9tICcuLi9jb21wb25lbnRzL0FkdmFudGFnZXMuc3ZlbHRlJztcbiAgaW1wb3J0IEZlYXR1cmVzIGZyb20gJy4uL2NvbXBvbmVudHMvRmVhdHVyZXMuc3ZlbHRlJztcbiAgaW1wb3J0IEZvb3RlciBmcm9tICcuLi9jb21wb25lbnRzL0Zvb3Rlci5zdmVsdGUnO1xuXG4gIGxldCBjdXJyZW50T2JzZXJ2ZWRJdGVtID0gbnVsbDtcblxuICBmdW5jdGlvbiBvYnNlcnZlKCkge1xuICAgIGNvbnN0IG9ic2VydmVkSXRlbXMgPSBuZXcgTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBjYWxsYmFjayhlbnRyaWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgb2JzZXJ2ZWRJdGVtcy5zZXQoXG4gICAgICAgICAgZW50cnkudGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKSxcbiAgICAgICAgICBlbnRyeS5pc0ludGVyc2VjdGluZyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dCA9IFsuLi5vYnNlcnZlZEl0ZW1zLmVudHJpZXMoKV0ucmV2ZXJzZSgpLmZpbmQoKFtfLCBpXSkgPT4gaSk7XG5cbiAgICAgIGlmIChuZXh0ICYmIG5leHRbMF0pIHtcbiAgICAgICAgY3VycmVudE9ic2VydmVkSXRlbSA9IG5leHRbMF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2FsbGJhY2ssIHtcbiAgICAgIHRocmVzaG9sZDogMC4yLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucGF0aCcpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBbLi4ubm9kZXNdKSB7XG4gICAgICBvYnNlcnZlZEl0ZW1zLnNldChub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSwgZmFsc2UpO1xuICAgICAgaW8ub2JzZXJ2ZShub2RlKTtcbiAgICB9XG4gIH1cblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBvYnNlcnZlKCk7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgOmdsb2JhbChzdmcpIHtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG5cbiAgbWFpbiB7XG4gICAgei1pbmRleDogMTtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cbjwvc3R5bGU+XG5cbjxCYWNrZ3JvdW5kIC8+XG48SGVhZGVyIHtjdXJyZW50T2JzZXJ2ZWRJdGVtfSAvPlxuXG48bWFpbj5cbiAgPERvd25sb2FkIC8+XG4gIDxBZHZhbnRhZ2VzIC8+XG4gIDxGZWF0dXJlcyAvPlxuPC9tYWluPlxuXG48Rm9vdGVyIC8+XG4iXSwibmFtZXMiOltd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
